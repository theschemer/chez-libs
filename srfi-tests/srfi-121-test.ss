(import (rnrs)   
        (srfi :121 generators)
        (only (srfi :1 lists) unfold)
        (srfi :64 testing))

(test-begin "srfi-121-generators")

(test-equal '() (generator->list (generator)))
(test-equal '(1 2 3) (generator->list (generator 1 2 3)))
(test-equal '(8 9 10) (generator->list (make-iota-generator 3 8)))
(test-equal '(8 10 12) (generator->list (make-iota-generator 3 8 2)))
(test-equal '(3 4 5 6) (generator->list (make-range-generator 3) 4))
(test-equal '(3 4 5 6 7) (generator->list (make-range-generator 3 8)))
(test-equal '(3 5 7) (generator->list (make-range-generator 3 8 2)))
(define g
  (make-coroutine-generator
    (lambda (yield) (let loop ((i 0))
                      (when (< i 3) (yield i) (loop (+ i 1)))))))
(test-equal '(0 1 2) (generator->list g))
(test-equal '(1 2 3 4 5) (generator->list (list->generator '(1 2 3 4 5))))
(test-equal '(1 2 3 4 5) (generator->list (vector->generator '#(1 2 3 4 5))))
(test-equal '(5 4 3 2 1) (generator->list (reverse-vector->generator '#(1 2 3 4 5))))
(test-equal '(#\a #\b #\c #\d #\e) (generator->list (string->generator "abcde")))
(test-equal '(10 20 30) (generator->list (bytevector->generator (bytevector 10 20 30))))
(define (for-each-digit proc n)
  (when (> n 0)
    (call-with-values (lambda () (div-and-mod n 10))
                      (lambda (div rem)
                        (proc rem)
                        (for-each-digit proc div)))))
(test-equal '(5 4 3 2 1) (generator->list
                           (make-for-each-generator for-each-digit
                                                    12345)))
(test-equal '(0 2 4 6 8 10) (generator->list
                              (make-unfold-generator
                                (lambda (s) (> s 5))
                                (lambda (s) (* s 2))
                                (lambda (s) (+ s 1))
                                0)))

(test-equal '(a b 0 1) (generator->list (gcons* 'a 'b (make-range-generator 0 2))))
(test-equal '(0 1 2 0 1) (generator->list (gappend (make-range-generator 0 3)
                                                   (make-range-generator 0 2))))
(test-equal '() (generator->list (gappend)))
(define g1 (generator 1 2 3))
(define g2 (generator 4 5 6 7))
(define (proc . args) (values (apply + args) (apply + args)))
(test-equal '(15 22 31) (generator->list (gcombine proc 10 g1 g2)))
(test-equal '(1 3 5 7 9) (generator->list (gfilter
                                            odd?
                                            (make-range-generator 1 11))))
(test-equal '(2 4 6 8 10) (generator->list (gremove
                                             odd?
                                             (make-range-generator 1 11))))
(let ((g (make-range-generator 1 5)))
  (test-equal '(1 2 3) (generator->list (gtake g 3)))
  (test-equal '(4) (generator->list g))
  (test-equal '(1 2) (generator->list (gtake (make-range-generator 1 3) 3)))
  (test-equal '(1 2 0) (generator->list (gtake (make-range-generator 1 3) 3 0)))
  (test-equal '(3 4) (generator->list (gdrop (make-range-generator 1 5) 2))))
(define (small? x) (< x 3))
(let ((g (make-range-generator 1 5)))
  (test-equal '(1 2) (generator->list (gtake-while small? g))))
(let ((g (make-range-generator 1 5)))
  (test-equal '(3 4) (generator->list (gdrop-while small? g)))
  (test-equal '() (generator->list (gdrop-while (lambda args #t) (generator 1 2 3))))
  (test-equal '(0.0 1.0 0 2) (generator->list (gdelete 1
                                                       (generator 0.0 1.0 0 1 2))))
  (test-equal '(0.0 0 2) (generator->list (gdelete 1
                                                   (generator 0.0 1.0 0 1 2)
                                                   =)))
  (test-equal '(a c e) (generator->list (gindex (list->generator '(a b c d e f))
                                                (list->generator '(0 2 4)))))
  (test-equal '(a d e) (generator->list (gselect (list->generator '(a b c d e f))
                                                 (list->generator '(#t #f #f #t #t #f)))))
  (test-equal '(1 2 3) (generator->list (gdelete-neighbor-dups
                                          (generator 1 1 2 3 3 3)
                                          =)))
  (test-equal '(1) (generator->list (gdelete-neighbor-dups
                                      (generator 1 2 3)
                                      (lambda args #t)))))

;; no test for plain generator->list (used throughout)
(test-equal '(1 2 3) (generator->list (generator 1 2 3 4 5) 3))
(test-equal '(5 4 3 2 1) (generator->reverse-list (generator 1 2 3 4 5)))
(test-equal '#(1 2 3 4 5) (generator->vector (generator 1 2 3 4 5)))
(test-equal '#(1 2 3) (generator->vector (generator 1 2 3 4 5) 3))
(test-equal "abc" (generator->string (generator #\a #\b #\c)))
(test-equal '(e d c b a . z) 
            (call-with-port (open-input-string "a b c d e")
                            (lambda (port) 
                              (generator-fold cons 'z (lambda () (read port))))))

(define n 0)
(generator-for-each (lambda values (set! n (apply + values)))
                    (generator 1) (generator 2) (generator 3))
(test-equal 6 n)
(test-equal 3 (generator-find (lambda (x) (> x 2)) (make-range-generator 1 5)))
(test-equal 2 (generator-count odd? (make-range-generator 1 5)))
(let ((g (make-range-generator 2 5)))
  (test-equal #t (generator-any odd? g))
  (test-equal '(4) (generator->list g)))
(let ((g (make-range-generator 2 5)))
  (test-equal #f (generator-every odd? g))
  (test-equal '(3 4) (generator->list g))
  (test-equal '(#\a #\b #\c) (generator-unfold (make-for-each-generator string-for-each "abc") unfold)))

(test-end)
